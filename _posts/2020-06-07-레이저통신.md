---
title:  "레이저통신"
excerpt: "BFS 백준 Java"

categories:
  - Baekjoon_Algorithm
tags:
  - BFS
  - 백준
  - Java_algorithm
last_modified_at: 2020-06-07
---

```
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
  static int c;
  static int r;
  static char[][] arr;
  static int min = Integer.MAX_VALUE;
  static boolean[][] che;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    c = sc.nextInt();
    r = sc.nextInt();

    arr = new char[r][c];

    int x = -1;
    int y = -1;

    int x1 = -1;
    int y1 = -1;

    boolean cheche = false;
    for (int i = 0; i < r; i++) {
      String str = sc.next();
      for (int j = 0; j < c; j++) {
        arr[i][j] = str.charAt(j);
        if (arr[i][j] == 'C' && !cheche) {
          x = i;
          y = j;
          cheche = true;
        } else if (arr[i][j] == 'C' && cheche) {
          x1 = i;
          y1 = j;
        }
      }
    }

//		System.out.println(x + " " + y);
//		System.out.println(x1 + " " + y1);

    Queue<Node> q = new LinkedList<>();

    int[][] che = new int[r][c];

    for (int i = 0; i < r; i++) {
      for (int j = 0; j < c; j++) {
        che[i][j] = Integer.MAX_VALUE;
      }
    }

    che[x][y] = 0;

    q.add(new Node(x, y, -1, 0));

    while (!q.isEmpty()) {
      Node node = q.poll();
      //System.out.println(node.r + " " + node.c + " " + node.type);
      for (int k = 0; k < 4; k++) {
        int cnt = node.cnt;
        int nr = node.r + dr[k];
        int nc = node.c + dc[k];
        if (nr < 0 || nc < 0 || nr >= r || nc >= c || arr[nr][nc] == '*')
          continue;
        if (k != node.type)
          cnt = cnt + 1;
        if (che[nr][nc] >= cnt) {
          che[nr][nc] = cnt;
          q.add(new Node(nr, nc, k, cnt));
        }
      }
    }
//		for (int i = 0; i < r; i++) {
//			for (int j = 0; j < c; j++) {
//				System.out.print(che[i][j]);
//			}
//			System.out.println();
//		}
//
    System.out.println(che[x1][y1] - 1);

  }

  static int[] dr = { -1, 1, 0, 0 };
  static int[] dc = { 0, 0, -1, 1 };

  static class Node {
    int r, c, type, cnt;

    Node(int r, int c, int type, int cnt) {
      this.r = r;
      this.c = c;
      this.type = type;
      this.cnt = cnt;
    }
  }
}
```

# 문제
크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.

'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.

레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\')을 설치해서 방향을 90도 회전시킬 수 있다. 

아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '*'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.
```
7 . . . . . . .         7 . . . . . . .
6 . . . . . . C         6 . . . . . /-C
5 . . . . . . *         5 . . . . . | *
4 * * * * * . *         4 * * * * * | *
3 . . . . * . .         3 . . . . * | .
2 . . . . * . .         2 . . . . * | .
1 . C . . * . .         1 . C . . * | .
0 . . . . . . .         0 . \-------/ .
  0 1 2 3 4 5 6           0 1 2 3 4 5 6
```

# 입력
첫째 줄에 W와 H가 주어진다. (1 ≤ W, H ≤ 100)

둘째 줄부터 H개의 줄에 지도가 주어진다. 지도의 각 문자가 의미하는 것은 다음과 같다.

.: 빈 칸
*: 벽
C: 레이저로 연결해야 하는 칸
'C'는 항상 두 개이고, 레이저로 연결할 수 있는 입력만 주어진다.

# 출력
첫째 줄에 C를 연결하기 위해 설치해야 하는 거울 개수의 최솟값을 출력한다.

# 예제 입력 1 

```
7 8
.......
......C
......*
*****.*
....*..
....*..
.C..*..
.......
```

# 예제 출력 1 

```
3
```
