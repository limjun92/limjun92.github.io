---
title:  "1장. 자료구조와 알고리즘"
toc: true
toc_sticky: true
categories:
  - Algorithm
tags:
  - Algorithm
last_modified_at: 2020-07-31
---

# 두 수의 합
숫자들의 배열이 주어지고 표적 숫자가 주어졌다고 합시다.  
배열에 주어진 숫자들 중 두 개의 숫자를 더하면 표적 숫자가 되는데요,   
이때 어떤 두 수를 더하면 표적숫자가 되는지 찾는 문제를 풀어 봅시다.  
예를 들어서, [2, 8, 19, 37, 4, 5] 가 배열로 주어지고  
12 가 표적으로 주어지면 8,4 를 찾아내시면 됩니다.  

* 입력 배열에는 중복되는 수가 없습니다.
* 입력 배열에는 합해서 표적이 되는 어떤 두 수가 반드시 있습니다.
* 출력의 순서는 상관 없습니다. 위 예시의 경우, 8,4 와 4,8은 둘 다 정답으로 인정합니다.

```python
def twoSum(nums, target):
#    for n in nums:
#        if target - n in nums:
#            return target-n, n

    nums.sort()
    
    start = 0
    end = len(nums) - 1
    # 2 4 5 8 19 37
    while True:
        if nums[start] + nums[end] == target:
            return nums[start], nums[end]
        elif nums[start] + nums[end] > target:
            end-=1
        else
            start+=1
def main():
    print(twoSum([2, 8, 19, 37, 4, 5], 12)) 

if __name__ == "__main__":
    main()
```
---
* 배열의 시작점과 끝점에서 시작해서 시간복잡도가 효율적이다
* 주석의 방식 풀면 배열을 2번 돈다(비 효율적)

# 가장 큰 두 수의 차
0보다 큰 정수들의 배열이 주어졌다고 합시다.   
여기서 가능한 모든 서로 다른 두 숫자의 차이를 고려 해 보고,   
이중 가장 큰 차이를 반환하는 함수를 적어봅시다. 예를 들어서,   
[2, 8, 19, 37, 4, 5, 12, 50, 1, 34, 23] 가 입력으로 주어졌을 경우   
가장 큰 차이를 내는 숫자쌍은 50-1 = 49 입니다.  

```python
def maxTwoDiff(nums):
    min = nums[0]
    max = nums[0]
    
    for i in nums:
        if min > i:
            min = i
        if max < i:
            max = i
    
    return max - min

def main():
    print(maxTwoDiff([2, 8, 19, 37, 4, 5, 12, 50, 1, 34, 23])) # 49가 리턴되어야 합니다.

if __name__ == "__main__":
    main()
```
---
* sort를 사용해서 끝값에서 첫번째 값을 빼면 시각복잡도 비효율적
