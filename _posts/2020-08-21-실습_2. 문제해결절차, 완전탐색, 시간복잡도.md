---
title:  "실습_2. 문제해결절차, 완전탐색, 시간복잡도"
excerpt: "알고리즘의 정석"
toc: true
toc_sticky: true
categories:
  - Algorithm
tags:
  - Algorithm
last_modified_at: 2020-08-21
---

# 실습

## 연속 부분 최대합
n개의 숫자가 주어질 때, 연속 부분을 선택하여 그 합을 최대화 하는 프로그램을 작성하시오. 예를 들어, 다음과 같이 8개의 숫자가 있다고 하자.
  
1 2 -4 5 3 -2 9 -10
  
이 때, 연속 부분이란 연속하여 숫자를 선택하는 것을 말한다. 가능한 연속 부분으로써 [1, 2, -4], [5, 3, -2, 9], [9, -10] 등이 있을 수 있다. 이 연속 부분들 중에서 가장 합이 큰 연속 부분은 [5, 3, -2, 9] 이며, 이보다 더 합을 크게 할 수는 없다. 따라서 연속 부분 최대합은 5+3+(-2)+9 = 15 이다.
  
* 입력 예시

```
1 2 -4 5 3 -2 9 -10
```

* 출력 예시

```
15
```

* 문제 조건
입력되는 수의 개수는 최대 100개입니다.

```python
import sys

def getSubsum(data) :
    '''
    n개의 숫자가 list로 주어질 때, 그 연속 부분 최대합을 반환하는 함수를 작성하세요.
    '''
    sum = 0
    maxs = 0
    for i in range(1,len(data)+1):
        #print(i)
        for j in range(0, len(data) - i + 1):
            #print(" ",j)
            for k in range(j,j+i):
                sum+=data[k]
            maxs = max(sum,maxs)
            sum = 0
    
    return maxs

def main():
    '''
    이 부분은 수정하지 마세요.
    '''

    data = [int(x) for x in input().split()]

    print(getSubsum(data))

if __name__ == "__main__":
    main()
```

## 멱집합 구하기
집합 A에 다하여, A의 모든 부분집합을 원소로 가지는 집합을 A의 멱집합이라고 한다. 예를 들어, 집합 A의 원소가 {1, 2, 3} 일 경우, A의 멱집합은 다음과 같이 8개의 원소를 갖는 집합이다.
  
{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}
  
집합 A의 원소는 1부터 nn까지의 자연수로 구성된다. nn이 주어질 때, A의 멱집합의 원소를 사전 순서대로 모두 출력하는 프로그램을 작성하시오. 단, 공집합은 제외하고 출력한다.

* 입력 예시

```
3
```

* 출력 예시

```
1
1 2
1 2 3
1 3
2
2 3
3
```

* 문제 조건  
원소의 개수는 10개를 넘지 않습니다.  
공집합은 출력하지 않습니다.  

```python
import sys

def powerSet(n) :
    '''
    n개의 원소를 가지는 집합 A의 멱집합의 원소를 사전 순서대로 list로 반환하는 함수를 작성하시오.

    예를 들어, n = 3 일 경우 다음의 list를 반환한다.

    [ [1], [1, 2], [1, 3], [1, 2, 3], [2], [2, 3], [3] ]
    '''
    
    def ham(k, n):
        if k == n:
            return [[k]]
            
        re = ham(k+1,n)
        arr = [[k]]
        for i in range(len(re)):
            arr += [[k]+re[i]]
        arr += re
        print(arr)
        return arr
    
    return ham(1,n)

def main():
    '''
    이 부분은 수정하지 마세요.
    '''

    n = int(input())

    result = powerSet(n)
    
    for line in result :
        print(*line)

if __name__ == "__main__":
    main()
```

## 균형 맞추기
nn개의 숫자가 주어진다. 이제 이 숫자를 두 개의 그룹으로 나눌 것이다. 예를 들어 5개의 숫자 [1, -3, 4, 5, -2] 가 주어진다면, 이를 두 개의 그룹으로 나누는 경우는 여러가지가 있을 수 있다. 가능한 경우로써 [1, -3], [4, 5, -2] 가 있을 수 있고, 또 다른 경우로는 [1, 4, -2], [-3, 5] 가 있을 수 있다.
  
나눈 두 그룹을 A, B라고 할 때, (A의 원소의 합) - (B의 원소의 합) 의 절댓값을 최소화 하는 프로그램을 작성하시오. 위의 예제에서는 A = [1, 4, -2], B = [-3, 5] 라고 하였을 때 (A의 원소의 합) - (B의 원소의 합) 의 절댓값 = |3 - 2| = 1 이며, 이보다 더 작은 값을 만드는 A, B는 존재하지 않는다.
  
이 경우 절댓값의 최솟값인 1을 출력하면 된다.
  
* 입력 예시

```
1 -3 4 5 -2
```

* 출력 예시

```
1
```

* 문제 조건
입력되는 수는 최대 20개를 넘지 않는다.

```python
import sys

def makeEqual(data) :
    '''
    n개의 숫자를 두 그룹 A, B로 나눈다고 할 때,

    | (A의 원소의 합) - (B의 원소의 합) | 의 최솟값을 반환하는 함수를 작성하시오.
    
    '''

    print(data)
    
    check = [False for i in range(len(data))]
    
    mins = [987654321]

    def ham(check, cnt):
        if cnt == len(check):
            #print(check)
            t_sum = 0
            f_sum = 0
            
            for i in range(len(check)):
                if check[i]:
                    t_sum+=data[i]
                else:
                    f_sum+=data[i]
            mins[0] = min(mins[0],abs(t_sum - f_sum))
            
            return
            
        check[cnt] = True
        ham(check,cnt+1)
        check[cnt] = False
        ham(check,cnt+1)
    
    ham(check,0)
    print(mins[0])
    return mins[0]

def main():
    '''
    이 부분은 수정하지 마세요.
    '''
    data = [int(x) for x in input().split()]
    print(makeEqual(data))
    
if __name__ == "__main__":
    main()
```
